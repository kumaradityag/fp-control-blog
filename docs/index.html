<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emulie Chhor">
<meta name="author" content="Kumaraditya Gupta">
<meta name="dcterms.date" content="2025-12-31">

<title>Lane Following using Pure Pursuit Control – Duckietown Course Project - Control</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-01b482d4fb5db1abb28b8ca678350662.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<meta name="mermaid-theme" content="default">
<script src="site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Duckietown Course Project - Control</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Final Report</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kumaradityag/fp-control-blog"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#trajectory-generation" id="toc-trajectory-generation" class="nav-link" data-scroll-target="#trajectory-generation">Trajectory Generation</a>
  <ul class="collapse">
  <li><a href="#methods-explored-but-discarded" id="toc-methods-explored-but-discarded" class="nav-link" data-scroll-target="#methods-explored-but-discarded">Methods explored but discarded</a></li>
  <li><a href="#final-approach-polynomial-fitting-with-ransac" id="toc-final-approach-polynomial-fitting-with-ransac" class="nav-link" data-scroll-target="#final-approach-polynomial-fitting-with-ransac">Final approach: polynomial fitting with RANSAC</a></li>
  <li><a href="#temporal-buffering-for-smoothness-and-consistency" id="toc-temporal-buffering-for-smoothness-and-consistency" class="nav-link" data-scroll-target="#temporal-buffering-for-smoothness-and-consistency">Temporal buffering for smoothness and consistency</a></li>
  </ul></li>
  <li><a href="#pure-pursuit-control" id="toc-pure-pursuit-control" class="nav-link" data-scroll-target="#pure-pursuit-control">Pure Pursuit Control</a>
  <ul class="collapse">
  <li><a href="#goal-point-calculation---line-circle-intersection-algorithm" id="toc-goal-point-calculation---line-circle-intersection-algorithm" class="nav-link" data-scroll-target="#goal-point-calculation---line-circle-intersection-algorithm">Goal Point Calculation - Line-circle intersection algorithm</a></li>
  <li><a href="#control-command-computation---follow-the-carrot-approach" id="toc-control-command-computation---follow-the-carrot-approach" class="nav-link" data-scroll-target="#control-command-computation---follow-the-carrot-approach">Control Command Computation - “Follow the carrot” approach</a></li>
  <li><a href="#control-command-computation---tangent-approach" id="toc-control-command-computation---tangent-approach" class="nav-link" data-scroll-target="#control-command-computation---tangent-approach">Control Command Computation - Tangent approach</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#pure-pursuit---follow-the-carrot" id="toc-pure-pursuit---follow-the-carrot" class="nav-link" data-scroll-target="#pure-pursuit---follow-the-carrot">Pure Pursuit - “Follow the carrot”</a></li>
  <li><a href="#pure-pursuit---tangent-approach" id="toc-pure-pursuit---tangent-approach" class="nav-link" data-scroll-target="#pure-pursuit---tangent-approach">Pure Pursuit - Tangent approach</a></li>
  <li><a href="#trajectory-visualization" id="toc-trajectory-visualization" class="nav-link" data-scroll-target="#trajectory-visualization">Trajectory Visualization</a></li>
  </ul></li>
  <li><a href="#testing" id="toc-testing" class="nav-link" data-scroll-target="#testing">Testing</a>
  <ul class="collapse">
  <li><a href="#understanding-the-project-architecture" id="toc-understanding-the-project-architecture" class="nav-link" data-scroll-target="#understanding-the-project-architecture">Understanding the project architecture</a></li>
  <li><a href="#setup" id="toc-setup" class="nav-link" data-scroll-target="#setup">Setup</a></li>
  <li><a href="#config-descriptions" id="toc-config-descriptions" class="nav-link" data-scroll-target="#config-descriptions">Config Descriptions</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a>
  <ul class="collapse">
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations">Limitations</a></li>
  <li><a href="#whats-next" id="toc-whats-next" class="nav-link" data-scroll-target="#whats-next">What’s next</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.md"><i class="bi bi-file-code"></i>Github (GFM)</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Lane Following using Pure Pursuit Control</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Authors</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Emulie Chhor </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Université de Montréal
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Kumaraditya Gupta </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Université de Montréal
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 31, 2025</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    This project replaces the standard Duckietown lane following stack with a system that generates a local centerline trajectory. By tracking this path with a Pure Pursuit controller, the duckiebot achieves smoother navigation through curves and better resilience to noisy sensor data compared to previous PID-based approach.
  </div>
</div>


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This project implements lane following on a Duckiebot using trajectory generation and pure pursuit control. The standard Duckietown lane-following stack estimates lane pose <span class="math inline">(d, \phi)</span> via a histogram filter and applies a PID controller on that estimate. In practice, the <span class="math inline">(d, \phi)</span> measurement can be noisy and discontinuous. Especially under partial occlusions, sparse lane markings, or during turns, which leads to jittery steering and reduced driving smoothness.</p>
<p>Instead of using <span class="math inline">(d, \phi)</span>, we use perception output (ground-projected lane segments) directly for local path construction. At each time step, we generate a <strong>centerline trajectory in the robot frame</strong>, apply temporal smoothing, and track the resulting path using <strong>pure pursuit control</strong>. This replaces explicit lane-state estimation with a path-tracking formulation: control commands are computed directly from the local trajectory, yielding smoother driving through curves.</p>
<p>The baseline stack consists of:</p>
<ul>
<li><strong>Line detection:</strong> color segmentation (white/yellow/red), edge detection (Canny), and line extraction (Hough) to produce lane-marker segments in the image.</li>
<li><strong>Ground projection:</strong> homography-based mapping from image coordinates to the ground plane using camera calibration.</li>
<li><strong>Lane estimation:</strong> a histogram filter over <span class="math inline">(d, \phi)</span> that fuses a kinematic prediction with segment-based updates.</li>
<li><strong>Control:</strong> PID-style steering using the estimated <span class="math inline">(d, \phi)</span>, typically with constant forward velocity and angular correction based on lateral and heading error.</li>
</ul>
<p>We keep <strong>line detection</strong> and <strong>ground projection</strong>, but replace the downstream modules:</p>
<ul>
<li><strong>Trajectory generation:</strong> compute a forward centerline path from projected segments, with robust fitting and temporal smoothing.</li>
<li><strong>Pure pursuit control:</strong> select a lookahead goal point on the path and compute curvature/steering commands to track it.</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
  A["Camera Image"] --&gt; B["Line Detection"]
  B --&gt; C["Ground Projection"]

  subgraph Baseline_Duckietown ["Baseline Duckietown Stack"]
    D["Lane Estimation"] --&gt; E["PID Control"]
  end

  subgraph Our_Project ["Our Project Stack"]
    F["Trajectory Generation"] --&gt; G["Pure Pursuit Control"]
  end

  C --&gt; D
  C --&gt; F
  E --&gt; H["Wheel Commands"]
  G --&gt; H
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Over this project we set and achieved these three goals:</p>
<ol type="1">
<li>Trajectory generation from detected lane segments, including temporal smoothing for stability.</li>
<li>Pure pursuit control on the generated trajectory.</li>
<li>Demonstrate continuous looped driving on a real Duckiebot in the lab Duckietown.</li>
</ol>
</section>
<section id="trajectory-generation" class="level2">
<h2 class="anchored" data-anchor-id="trajectory-generation">Trajectory Generation</h2>
<p>This module uses ground-projected lane detections in the robot frame: white points <span class="math inline">\mathcal{W}={(x_i,y_i)}</span> and yellow points <span class="math inline">\mathcal{Y}={(x_j,y_j)}</span>, where <span class="math inline">x</span> is forward distance and <span class="math inline">y</span> is lateral offset. The goal is to output a local centerline trajectory <span class="math inline">\Gamma={(x_k, y_k)}_{k=1}^{N}</span> over a fixed horizon <span class="math inline">x_k \in [0, \texttt{max\_forward}]</span>, suitable for pure pursuit. In practice, the key challenge is that the point sets are noisy (mainly due to false detections), so the trajectory generator must be robust and temporally stable.</p>
<section id="methods-explored-but-discarded" class="level3">
<h3 class="anchored" data-anchor-id="methods-explored-but-discarded">Methods explored but discarded</h3>
<p><strong>1) Midpoint pairing heuristic.</strong> We first attempted to construct the centerline by pairing boundary points and taking midpoints. Concretely, for each detected yellow point we found the nearest white point and defined the midpoint of the pair as a centerline sample. This fails on real hardware because white detections frequently “bleed” onto the yellow marker (e.g., due to lighting and segmentation artifacts). As a result, nearest-neighbor pairing becomes unreliable: midpoints drift toward a boundary and jump between inconsistent pairings across frames. The downstream fit then produces trajectories that are not representative of the lane center.</p>
<p><strong>2) Bézier fit + normal shift.</strong> We also tried fitting a Bézier curve to lane detections and shifting it inward by half the lane width using the curve normal. While geometrically appealing, this approach is brittle because the Bézier fit tends to be strongly influenced by individual detections. With sparse or noisy points, a single outlier can significantly change the curve shape, again producing unreliable trajectories and also with large frame-to-frame variations.</p>
</section>
<section id="final-approach-polynomial-fitting-with-ransac" class="level3">
<h3 class="anchored" data-anchor-id="final-approach-polynomial-fitting-with-ransac">Final approach: polynomial fitting with RANSAC</h3>
<p>What worked reliably was a robust polynomial fit in the ground plane, using RANSAC to reject outliers.</p>
<ol type="1">
<li>Choose which boundary to fit. In our experiments, fitting on white points was most stable (more consistent and typically more numerous). We default to <span class="math inline">\mathcal{W}</span>, and switch to <span class="math inline">\mathcal{Y}</span> only when there are insufficient white detections.</li>
</ol>
<div class="callout callout-style-default callout-caution callout-titled" title="White Point Filtering">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Caution</span>White Point Filtering
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Because the system is configured for right-hand driving, we sometimes detect white points from the adjacent (left) lane boundary. To prevent mixing these into the fit, we discard white points that lie too far to the left (beyond roughly half a lane width). This simple geometric filter significantly reduced “lane switching” behavior in the fitted curve.</p>
</div>
</div>
</div>
<ol start="2" type="1">
<li><p>Fit a polynomial model robustly. We fit <span class="math inline">y(x)</span> as a quadratic polynomial and use RANSAC so that spurious points (from floor, glare, or wrong-color detections) do not dominate the model. Intuitively, RANSAC repeatedly fits the curve to small random subsets and keeps the hypothesis that agrees with the largest set of points. Once these inliers are identified, the final curve is fit on all the inliers to ensure maximum accuracy. This gives a curve that follows the dominant lane boundary even when the input is noisy.</p></li>
<li><p>Convert boundary curve to centerline. Once we have a clean boundary curve, we compute the local normal direction along the curve and shift laterally by half the lane width to obtain the centerline.</p></li>
<li><p>Sample a fixed-horizon trajectory. We uniformly sample <span class="math inline">N</span> points in <span class="math inline">x</span> from <span class="math inline">0</span> to <span class="math inline">\texttt{max\_forward}</span> and evaluate the centerline model to produce the final trajectory points <span class="math inline">(x_k,y_k)</span>. This produces a consistent representation for pure pursuit (same number of points, same horizon, every frame).</p></li>
</ol>
</section>
<section id="temporal-buffering-for-smoothness-and-consistency" class="level3">
<h3 class="anchored" data-anchor-id="temporal-buffering-for-smoothness-and-consistency">Temporal buffering for smoothness and consistency</h3>
<p>A good single-frame trajectory is not enough as pure pursuit can be sensitive to frame-to-frame trajectory jumps, which show up as steering jitter. We therefore stabilize the trajectory over time with two mechanisms:</p>
<p><strong>1) Reject implausible trajectory flips.</strong> We compute a simple “heading proxy” from the trajectory midpoint (a point around the middle of the horizon). If the direction from the robot to this midpoint changes by more than a threshold <span class="math inline">\theta_{\text{thresh}}</span> compared to the previous frame, we treat the current trajectory as unreliable and reuse the previous one. An example of the <span class="math inline">\theta</span> computation is also shown in <a href="#fig-theta" class="quarto-xref">Figure&nbsp;1</a>. This catches cases where the fit snaps to the wrong structure for a frame (common under sparse or false detections).</p>
<div id="fig-theta" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-theta-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="assets/images/trajectory_theta.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-theta-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Heading change calulcation between the current and previous trajectory
</figcaption>
</figure>
</div>
<p><strong>2) Exponential smoothing of the lateral profile.</strong> When a trajectory is accepted, we still smooth it to reduce high-frequency noise: <span class="math display">
y^{\text{sm}}_{t} = \alpha*y_{t} + (1-\alpha)*y^{\text{sm}}_{t-1},
</span></p>
<p>applied pointwise across the sampled trajectory. The parameter <span class="math inline">\alpha</span> controls responsiveness vs.&nbsp;smoothness. This simple filter substantially reduces steering jitter while preserving curvature for cornering within the short planning horizon.</p>
<p>Overall, this pipeline produces a locally defined, robust, and temporally stable centerline trajectory from ground-projected lane points, which is then tracked by pure pursuit.</p>
<p>The code for trajectory generation can be found <a href="https://github.com/kumaradityag/fp-control/blob/628538e81f2285e2fee654630a9204dcadac7b19/packages/trajectory_planner/include/trajectory_generation.py#L107">here</a></p>
</section>
</section>
<section id="pure-pursuit-control" class="level2">
<h2 class="anchored" data-anchor-id="pure-pursuit-control">Pure Pursuit Control</h2>
<p>The second part of the project focused on enhancing the controller node using the “Pure Pursuit” algorithm, which enables the robot to adjust its path before the error accumulates. Similar to PID control, pure pursuit is a steering method that computes the linear (v) and angular velocity (<span class="math inline">\omega</span>). However, instead of relying on the cross-track error (CTE), the lateral distance between the vehicle and the centerlane, it relies on the pre-computed trajectory as a reference.</p>
<p>The pure pursuit controller consists of two keys steps:</p>
<ol type="1">
<li>Goal Point Computation: We determine the goal point to which the robot aims to reach</li>
<li>Control Commands Computation: We compute the linear and angular velocity required to make the duckie reach the computed goal point</li>
</ol>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
    A[Goal Point Computation] --&gt; B[Control Command Computation]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>If you are familiar with the “follow the carrot” analogy, pure pursuit control works fashionably in the same way: we make the robot (the donkey) move towards the goal point (the carrot), which we always keep at a distance <span class="math inline">L_d</span>, the lookahead distance. If the donkey is too far from the goal point, we “stick” it to the robot and make it turn more aggressively towards the goal point.</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/-PVFBGN_zoM?si=9V-fbQ8J0mmzbZtT" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<section id="goal-point-calculation---line-circle-intersection-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="goal-point-calculation---line-circle-intersection-algorithm">Goal Point Calculation - Line-circle intersection algorithm</h3>
<p>Many methods can be used to compute the goal point, but we decided to go with the “line-circle intersection” algorithm for its computational simplicity.</p>
<p>Mathematically speaking, the line-circle intersection algorithm tries to find the points where a straight line intersects the circle with radius R.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Understanding the maths behind the line-circle intersection algorithm">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Understanding the maths behind the line-circle intersection algorithm
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Given a circle centered at the origin with radius r and points P1(x1, y1) and P2(x2, y2). The implicit line equation for the closed-form geometry can be written as</p>
<p><span class="math display"> d_y x - d_x y + D = 0</span></p>
<p>where</p>
<ul>
<li><span class="math inline">D=x_1 y_2 - x_2 y_1</span></li>
<li><span class="math inline">d_x = x_2 - x_1</span></li>
<li><span class="math inline">d_y = y_2 - y_1</span></li>
</ul>
<p>The perpendicular projection of the origin onto the line is:</p>
<p><span class="math display">
\begin{aligned}
x_0 &amp;= \frac{D d_y}{d_r^2} \\
y_0 &amp;= \frac{-D d_x}{d_r^2}
\end{aligned}
</span></p>
<p>where <span class="math inline">dr= \sqrt{dx^2 + dy^2}</span></p>
<p>Since the closest point from the origin to the line is a perpendicular projection, we can determine the existence of the intersection using the distance from the origin to the line</p>
<p><span class="math display">\text{dist} = \frac{|D|}{d_r}</span></p>
<ul>
<li>If dist &gt; r, there are no intersection</li>
<li>If dist = r, one tangent intersection</li>
<li>If dist &lt; r, there are two intersections</li>
</ul>
<p>From the right-triangle geometry, we can find the distance along the line from the closest point to each intersection, which we can use to move from the closest point forward and backward along the line</p>
<p><span class="math display">h = \sqrt{r^2 - \left(\frac{D}{d_r}\right)^2}</span></p>
<p>The unit direction along the line is given by</p>
<p><span class="math display">\hat{\mathbf{u}} = \left( \frac{d_x}{d_r}, \frac{d_y}{d_r} \right)</span></p>
<p>This gives us the formula to compute the intesection points</p>
<p><span class="math display">
\mathbf{P}_{1,2}
=
\begin{pmatrix}
x_0 \\
y_0
\end{pmatrix}
\pm
h \,\hat{\mathbf{u}}
</span></p>
<p><span class="math display">
\begin{aligned}
x &amp;= \frac{D d_y \pm d_x \sqrt{r^2 d_r^2 - D^2}}{d_r^2} \\
y &amp;= \frac{-D d_x \pm d_y \sqrt{r^2 d_r^2 - D^2}}{d_r^2}
\end{aligned}
</span></p>
</div>
</div>
</div>
<p>Since the line-circle intersection method works for two points only and the trajectory is an array of points, given two consecutive trajectory points P1(x1, y2) and P2(x2, y2), the goal point P(x, y) can be found as follows:</p>
<ul>
<li><span class="math inline">x=\frac{D dy \pm sgn(dy) dx \sqrt{\Delta}}{L_d^2}</span></li>
<li><span class="math inline">y=\frac{-D dx \pm \| dy \| \sqrt{\Delta}}{L_d^2}</span></li>
</ul>
<p>Where</p>
<ul>
<li><span class="math inline">dx=x_2-x_1</span></li>
<li><span class="math inline">dy=y_2-y_1</span></li>
<li><span class="math inline">dr= \sqrt{dx^2 + dy^2}</span></li>
<li><span class="math inline">D=x_1 y_2 - x_2 y_1</span></li>
<li><span class="math inline">\Delta=r^2 dr^2 - D^2</span></li>
<li><span class="math inline">f(x) = \begin{cases} 0, &amp; x&lt;0 \\ x, &amp; x\ge 0 \end{cases}</span></li>
</ul>
<p>To determine the validity of the goal point computed, we can follow the following graph:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
    A[Discriminant] -- $$\Delta$$&lt;0 --&gt; B(No intersection Found) --&gt; E;
    A -- $$\Delta$$=0 --&gt; C(One Intersection Found);
    A -- $$\Delta$$&gt;0 --&gt; D(Two Intersections Found);
    E[Use last point in trajectory];
    F(Range Check);
    G[Select intersection closest to last goal point];
    C -- invalid --&gt; E;
    D -- both invalid --&gt; E;
    D -- one invalid --&gt; C;
    D -- both valid --&gt; G;
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Essentially, we compute the discriminant <span class="math inline">\Delta</span> to find valid intersections. The intersection we find is valid if <span class="math inline">\Delta \ge 0</span> and if it’s between the trajectory segment points.</p>
<p>The full implementation can be found inside the function <a href="https://github.com/kumaradityag/fp-control/blob/e145767ec9b8fbaf04f0cfd550c42bd7930a55fd/packages/pure_pursuit_control/include/pure_pursuit_controller/goal.py#L13">find_goal_point()</a></p>
</section>
<section id="control-command-computation---follow-the-carrot-approach" class="level3">
<h3 class="anchored" data-anchor-id="control-command-computation---follow-the-carrot-approach">Control Command Computation - “Follow the carrot” approach</h3>
<p>The first implementation of pure pursuit that we coded kept the linear velocity constant and only accounted for the angular velocity, which was calculated using the turn error between the robot heading and the goal point.</p>
<p>We define 3 parameters:</p>
<ul>
<li><code>lookahead_distance</code>: Circle radius at which the duckiebot sees</li>
<li><code>kp_steering</code>: How hard do we want to steer the wheel upon turn error</li>
<li><code>v_bar</code>: Linear velocity</li>
</ul>
<p>Consider the following picture,</p>
<p><img src="./assets/images/pure_pursuit_turn_angle.png" class="img-fluid"></p>
<p>The turn error can be computed</p>
<p><span class="math display">\alpha = tan(\frac{y_1-y_0}{x_1 - x_0})</span></p>
<p>Thus,</p>
<p><span class="math display">\omega = \text{kp\_sterring} \cdot \alpha</span></p>
<p>The code for the “follow the carrot” approach looks something like this:</p>
<div id="ce50ea83" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>goal_point, _ <span class="op">=</span> find_goal_point(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    path_points,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.current_pos,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    lookahead_distance,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.last_found_index,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>dx, dy <span class="op">=</span> (</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    goal_point[<span class="dv">0</span>] <span class="op">-</span> <span class="va">self</span>.current_pos[<span class="dv">0</span>],</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    goal_point[<span class="dv">1</span>] <span class="op">-</span> <span class="va">self</span>.current_pos[<span class="dv">1</span>],</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>abs_target_angle <span class="op">=</span> math.atan2(dy, dx)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>turn_error <span class="op">=</span> abs_target_angle <span class="op">-</span> np.deg2rad(<span class="va">self</span>.current_heading)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>L_d <span class="op">=</span> math.sqrt(dx<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> dy<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> v_bar</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> kp_steering <span class="op">*</span> turn_error</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>The full code implementation can be found in the function <a href="https://github.com/kumaradityag/fp-control/blob/e145767ec9b8fbaf04f0cfd550c42bd7930a55fd/packages/pure_pursuit_control/include/pure_pursuit_controller/pure_pursuit_controller.py#L23">compute_control_action()</a></p>
</section>
<section id="control-command-computation---tangent-approach" class="level3">
<h3 class="anchored" data-anchor-id="control-command-computation---tangent-approach">Control Command Computation - Tangent approach</h3>
<p>In order to improve the duckiebot performance around sharp corners, we wanted to adjust the linear velocity and angle velocity based on curvature. Similarly to how one would drive, we want our duckie to slow down around corner and speed up on when it drives straight ahead. To do so, we used a tangent based approach to find the curvature.</p>
<p>Consider the following picture:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./assets/images/pure_pursuit_turn_error.png" class="img-fluid figure-img"></p>
<figcaption>Courtesy of Purdue Sigbots</figcaption>
</figure>
</div>
<p>Using trigonometry, we find that</p>
<p><span class="math display">R = \frac{L_d}{2 sin(\alpha)}</span></p>
<div class="callout callout-style-default callout-note callout-titled" title="Deriving the radius formula">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Deriving the radius formula
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>As seen previously, given the current pos P0(x0, y0) and the goal point P1(x1, y1), the turn error <span class="math inline">\alpha</span> can be computed as</p>
<p><span class="math display">\alpha = tan(\frac{y_1 - y_0}{x_1 - x_0})</span></p>
<p>Since the goal point is at distance <span class="math inline">L_d</span> of the current position, the half-way point is at distance <span class="math inline">\frac{L_d}{2}</span> and thus</p>
<p><span class="math display">R = \frac{\frac{L_d}{2}}{sin(\alpha)} = \frac{L_d}{2 sin (\alpha)}</span></p>
</div>
</div>
</div>
<p>The curvature <span class="math inline">k</span> is defined as the inverse of the radius of the arc we want the duckie to travel. Because we want the linear velocity to be inversely proportional to the curvature (the higher the curvature, the lower the speed), we get the following formula for linear velocity</p>
<p><span class="math display">k = \frac{1}{R}</span> <span class="math display">v = \bar{v} * \frac{1}{k} = \bar{v} * R</span></p>
<p>To derive the angular error, now consider the diagram below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./assets/images/pure_pursuit_angular_error.png" class="img-fluid figure-img"></p>
<figcaption>Courtesy of Purdue Sigbots</figcaption>
</figure>
</div>
<p>Assuming that the robot finishes the turn after time <span class="math inline">\delta t</span>, we have that the left side (<span class="math inline">L_l</span>) and right side (<span class="math inline">L_R</span>) of the duckie turn with velocity</p>
<p><span class="math display">
\begin{aligned}
L_l
&amp;=
(\text{linearVel} - \text{turnVel}) \cdot \Delta t
=
\left( R - \frac{W}{2} \right) \cdot (2 \cdot \text{turnError})
\\[6pt]
L_r
&amp;=
(\text{linearVel} + \text{turnVel}) \cdot \Delta t
=
\left( R + \frac{W}{2} \right) \cdot (2 \cdot \text{turnError})
\end{aligned}
</span></p>
<p>Solving for turn velocity, we get that</p>
<p><span class="math display">
\frac{(\text{linearVel} - \text{turnVel}) \cdot \Delta t}
     {(\text{linearVel} + \text{turnVel}) \cdot \Delta t}
=
\frac{\left( R - \frac{W}{2} \right) \cdot (2 \cdot \text{turnError})}
     {\left( R + \frac{W}{2} \right) \cdot (2 \cdot \text{turnError})}
</span></p>
<p><span class="math display">
\frac{\text{linearVel} - \text{turnVel}}
     {\text{linearVel} + \text{turnVel}}
=
\frac{R - \frac{W}{2}}
     {R + \frac{W}{2}}
</span></p>
<p><span class="math display">
\left( R + \frac{W}{2} \right)\text{linearVel}
-
\left( R + \frac{W}{2} \right)\text{turnVel}
=
\left( R - \frac{W}{2} \right)\text{linearVel}
+
\left( R - \frac{W}{2} \right)\text{turnVel}
</span></p>
<p><span class="math display">
\text{turnVel}
=
\frac{W}{2R} \cdot \text{linearVel}
</span></p>
<p>And since <span class="math inline">R = \frac{\text{lookaheadDistance}}{2 \sin(\text{turnError})}</span>, the turn velocity</p>
<p><span class="math display">
\boxed{
\text{turnVel}
=
\frac{W \sin(\text{turnError})}
     {\text{lookaheadDistance}}
\cdot \text{linearVel}
}
</span></p>
<p>Thus, our curvature-based pure pursuit approach uses 4 parameters:</p>
<ul>
<li><code>width</code>: width of the duckiebot chassis</li>
<li><code>omega_factor</code>: how hard we want to turn the steering wheel, very similar to <code>kp_steering</code></li>
<li><code>v_bar</code>: default velocity</li>
<li><code>v_bar_min</code>: minimal linear velocity</li>
<li><code>v_bar_max</code>: maximal linear velocity</li>
</ul>
<div id="a7226bc5" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dx, dy <span class="op">=</span> (</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    goal_point[<span class="dv">0</span>] <span class="op">-</span> <span class="va">self</span>.current_pos[<span class="dv">0</span>],</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    goal_point[<span class="dv">1</span>] <span class="op">-</span> <span class="va">self</span>.current_pos[<span class="dv">1</span>],</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>abs_target_angle <span class="op">=</span> math.atan2(dy, dx)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>turn_error <span class="op">=</span> abs_target_angle <span class="op">-</span> np.deg2rad(<span class="va">self</span>.current_heading)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>L_d <span class="op">=</span> math.sqrt(dx<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> dy<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> np.<span class="bu">abs</span>(L_d <span class="op">/</span> (<span class="fl">2.0</span> <span class="op">*</span> np.sin(turn_error)))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> np.clip(v_bar <span class="op">*</span> R, v_bar_min, v_bar_max)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> omega_factor <span class="op">*</span> (width <span class="op">*</span> np.sin(turn_error) <span class="op">*</span> v) <span class="op">/</span> L_d</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>The full code can be found <a href="https://github.com/kumaradityag/fp-control/blob/main/packages/pure_pursuit_control/include/pure_pursuit_controller/pure_pursuit_controller.py#L23">here</a></p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="pure-pursuit---follow-the-carrot" class="level3">
<h3 class="anchored" data-anchor-id="pure-pursuit---follow-the-carrot">Pure Pursuit - “Follow the carrot”</h3>
<p>Althought this approach is quite simple, we found that it performed relatively well with the right parameters. When driving at lower speed, the duckiebot was able to turn the corner gracefully without too much oscillation. However, as soon as we get it to drive a bit faster, it wasn’t very good at turning around corners, especially in the inner lane due to its sharp corners.</p>
<p>Outer Loop:</p>
<iframe src="https://drive.google.com/file/d/1ga7rnIbhwDYizVIQUI2vUZ9cj6RG9D2b/preview" style="width: 100%; aspect-ratio: 16/9;" allow="autoplay; fullscreen; picture-in-picture" frameborder="0"></iframe>
<p>Inner Loop:</p>
<iframe src="https://drive.google.com/file/d/1YI_d33H-vBUEEcU9B2leVrXtq-WjtjrI/preview" style="width: 100%; aspect-ratio: 16/9;" allow="autoplay; fullscreen; picture-in-picture" frameborder="0"></iframe>
</section>
<section id="pure-pursuit---tangent-approach" class="level3">
<h3 class="anchored" data-anchor-id="pure-pursuit---tangent-approach">Pure Pursuit - Tangent approach</h3>
<p>With the tangent approach we can observe the duckiebot going faster on the straights and slower around the corners. However this approach did not produce strictly better results than the “follow the carrot” approach. As after turning around the corner, the tangent approach overcorrected way more than with the naive approach.</p>
<p>Some of these results can be explained because we changed the map on which the duckie drove, which generated a worse trajectory than the test we had generated prior.</p>
<p>Outer Loop:</p>
<iframe src="https://drive.google.com/file/d/1pXbwknVJrbhRgPkGaJ3Z8cl9AH0PRWUk/preview" style="width: 100%; aspect-ratio: 16/9;" allow="autoplay; fullscreen; picture-in-picture" frameborder="0"></iframe>
<p>Inner Loop:</p>
<iframe src="https://drive.google.com/file/d/1dap8M6RoXJU4CMMKh4Rm86MiKA9e_1ej/preview" style="width: 100%; aspect-ratio: 16/9;" allow="autoplay; fullscreen; picture-in-picture" frameborder="0"></iframe>
</section>
<section id="trajectory-visualization" class="level3">
<h3 class="anchored" data-anchor-id="trajectory-visualization">Trajectory Visualization</h3>
<p>We also visualize the generated trajectory (shown in red points) along with the detected white and yellow bouundries in the two videos below.</p>
<p>Trajectory Outer Loop:</p>
<iframe src="https://drive.google.com/file/d/1F7V--gRNKAjZdDYyXZirzwYqiHWR51qc/preview" style="width: 100%; aspect-ratio: 2/1;" allow="autoplay; fullscreen; picture-in-picture" frameborder="0"></iframe>
<p>Trajectory Inner Loop:</p>
<iframe src="https://drive.google.com/file/d/1p1YS1dPKCC4cZ8kCuNYXfqpnl9Z63at6/preview" style="width: 100%; aspect-ratio: 2/1;" allow="autoplay; fullscreen; picture-in-picture" frameborder="0"></iframe>
</section>
</section>
<section id="testing" class="level2">
<h2 class="anchored" data-anchor-id="testing">Testing</h2>
<p>Testing instructions are also available in the README of the project repository, <a href="https://github.com/kumaradityag/fp-control">here</a>. They are also copied here for completeness.</p>
<p>To test the code, first clone the project GitHub repository.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone git@github.com:kumaradityag/fp-control</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>These instructions assume you have the following:</p>
<ul>
<li>A duckietown-shell. You can verify that you have sucessfully installed it using <code>dts --version</code>. If that’s not the case, please follow the instructions <a href="https://docs.duckietown.com/daffy/opmanual-duckiebot/setup/setup_laptop/setup_dt_shell.html">here</a></li>
<li>You have created your virtual duckiebot. You can verify that your virtual duckie exists with the command <code>dts duckiebot virtual start vbot</code> and then <code>dts fleet discover</code>. <code>vbot</code> is the name of our virtual duckie, but feel free to replace it with your own virtual duckie name</li>
<li>You have your real life duckiebot setup. This step is only required if you want to test the demo in real life. If you want to get your duckie hardware, see the official documentation <a href="https://docs.duckietown.com/daffy/opmanual-duckiebot/preliminaries_hardware/get_hardware/index.html">here</a></li>
</ul>
<section id="understanding-the-project-architecture" class="level3">
<h3 class="anchored" data-anchor-id="understanding-the-project-architecture">Understanding the project architecture</h3>
<p>The most important directories of our projects are <code>packages/trajectory_planner</code> and <code>packages/pure_pursuit_control</code>, which are where our trajectory generation code and our pure pursuit code live.</p>
<p>Virtual and physical duckiebot can behave slightly differently because of real-world physics, so they respond to the same parameters differently. Additionally, in our current setup, driving in the inner or outter lane also require different parameters. Therefore, you will probably need to tune your parameters for your own duckiebot.</p>
<p>The configs for the trajectory planner and the pure pursuit controller can be found respectively inside <code>packages/trajectory_planner/config/trajectory_planner_node/default.yaml</code> and <code>packages/pure_pursuit_control/config/pure_pursuit_control_node/default.yaml</code>. Additional config information is present at the bottom.</p>
</section>
<section id="setup" class="level3">
<h3 class="anchored" data-anchor-id="setup">Setup</h3>
<p>You will need at least three terminals to spin and view everything needed. Replace <code>&lt;duckie_name&gt;</code> with your duckiebot name.</p>
<p>Preliminaries (in every terminal):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set robot name</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">ROBOT_NAME</span><span class="op">=&lt;</span>duckie_name<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Preliminaries for the matrix (if needed):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> matrix run <span class="at">--standalone</span> <span class="at">--map</span> ./assets/duckiematrix/map/loop/</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> matrix attach <span class="va">$ROBOT_NAME</span> map_0/vehicle_0</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>All these other commands need to run from the project repository:</p>
<p>In terminal 1:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel build <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-f</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In terminal 2:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># To view the debug images</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> duckiebot image_viewer <span class="va">$ROBOT_NAME</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In terminal 3:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For emergency stop</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> duckiebot keyboard_control <span class="va">$ROBOT_NAME</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In terminal 4:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># If you want to manually change some of the param values</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ssh</span> duckie@<span class="op">&lt;</span>duckie_name<span class="op">&gt;</span>.local</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># After logging into your duckiebot:</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> exec <span class="at">-it</span> ros-interface bash</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ex">rosparam</span> list <span class="kw">|</span> <span class="fu">grep</span> <span class="op">&lt;</span>param_search_query<span class="op">&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ex">rosparam</span> set <span class="op">&lt;</span>param_name<span class="op">&gt;</span> <span class="op">&lt;</span>value<span class="op">&gt;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="run-the-carrot-approach" class="level4">
<h4 class="anchored" data-anchor-id="run-the-carrot-approach">Run the carrot approach</h4>
<p>In terminal 1:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For physical duckie</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel run <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-L</span> lane-following-carrot-physical-outer</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel run <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-L</span> lane-following-carrot-physical-inner</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># For virtual duckie</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel run <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-L</span> lane-following-carrot-virtual-outer</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel run <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-L</span> lane-following-carrot-virtual-inner</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="run-the-tangent-approach" class="level4">
<h4 class="anchored" data-anchor-id="run-the-tangent-approach">Run the tangent approach</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For physical duckie</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel run <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-L</span> lane-following-tangent-physical-outer</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel run <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-L</span> lane-following-tangent-physical-inner</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># For virtual duckie</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel run <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-L</span> lane-following-tangent-virtual-outer</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ex">dts</span> devel run <span class="at">-H</span> <span class="va">$ROBOT_NAME</span> <span class="at">-L</span> lane-following-tangent-virtual-inner</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="config-descriptions" class="level3">
<h3 class="anchored" data-anchor-id="config-descriptions">Config Descriptions</h3>
<p>The trajectory planner node has the following config parameters:</p>
<ul>
<li><code>min_forward</code>: minimum distance at which we consider trajectory points</li>
<li><code>max_forward</code>: maximum distance at which we consider trajectory points</li>
<li><code>n_samples</code>: number of points generated for the trajectory</li>
<li><code>lane_width</code>: width of the lane in meters from Duckietown docs</li>
<li><code>epsilon</code>: to correct the lane width by a small margin</li>
<li><code>default_mode</code>: relying on WHITE/YELLOW lane</li>
<li><code>yellow_pts_threshold</code>: minimum points in the trajectory for the yellow lane to be valid</li>
<li><code>white_pts_threshold</code>: minimum points in the trajectory for the white lane to be valid</li>
<li><code>ransac_max_iterations</code>: number of iterations for ransac to compute inliers</li>
<li><code>ransac_distance_threshold</code>: max error to separate inliers from outliers (in m)</li>
<li><code>poly_degree</code>: polynomial degree for ransac</li>
<li><code>buffer_size</code>: number of previous trajectory saved in buffer</li>
<li><code>buffer_smooth_alpha</code>: float number between 0-1 used to smooth out current trajectory based on the previous one</li>
<li><code>buffer_theta_threshold</code>: theta angle threshold for heading change in degrees</li>
</ul>
<p>The pure pursuit control node has the following config parameters:</p>
<ul>
<li><code>lookahead_distance</code>: distance at which the pure pursuit controller look ahead (in cm)</li>
<li><code>v_bar</code>: linear velocity</li>
<li><code>v_bar_max</code>: maximal linear velocity</li>
<li><code>v_bar_min</code>: minimal linear velocity</li>
<li><code>width</code>: chassis width of the duckie. Should stay 0.1</li>
<li><code>omega_factor</code>: how hard we want the duckie to turn</li>
</ul>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This project successfully implemented a modular lane-following pipeline for the Duckiebot, moving away from the state estimation approach in favor of explicit trajectory generation and geometric path tracking. By leveraging robust polynomial fitting on ground-projected lane segments, we created a system capable of generating a centerline trajectory and following it using pure pursuit control.</p>
<p>Our experiments demonstrated that a pure pursuit controller, allows for continuous driving in both simulation and physical Duckietowns. While the transition from simulation to hardware introduced challenges regarding sensor noise and latency, the system proved that looking ahead at a generated path yields intuitive driving behavior. Our implementation also offers a flexible foundation for implementing more advanced planners and dynamic controllers in the future and general experimentation.</p>
<section id="limitations" class="level3">
<h3 class="anchored" data-anchor-id="limitations">Limitations</h3>
<p>Although our pipeline performed well in simulation and achieved successful loops in real-world tests, the gap between simulation and reality exposed some weaknesses in both our trajectory generation and control algorithms.</p>
<section id="trajectory-generation-limitations" class="level4">
<h4 class="anchored" data-anchor-id="trajectory-generation-limitations">Trajectory Generation Limitations</h4>
<ul>
<li><strong>Single-Boundary Dependency:</strong> Currently, the system fits a curve to either the white <em>or</em> the yellow lane markings, but does not fuse both simultaneously. This view of the road geometry creates instability: if the chosen boundary becomes sparse (but still above a given threshold) or occluded, the fit degrades immediately, even if the other boundary is clearly visible. A robust system could fit both boundaries jointly to maximize data utilization.</li>
<li><strong>Model Constraints (The “S-Curve” Problem):</strong> We model the lane as a quadratic polynomial. While robust for simple turns, a parabola cannot model inflection points (S-curves). If the vision horizon extends through a left-then-right turn, the quadratic fit will average the two curves into a straight line, causing the robot to drive off-road. Testing with a cubic polynomial in these situations might prove useful.</li>
</ul>
</section>
<section id="pure-pursuit-limitations" class="level4">
<h4 class="anchored" data-anchor-id="pure-pursuit-limitations">Pure Pursuit Limitations</h4>
<p>Despite its computational efficiency, the pure pursuit controller exhibited some flaws when deployed on physical hardware:</p>
<ul>
<li><strong>Static Lookahead Sensitivity:</strong> The controller is rigid; a fixed lookahead distance cannot handle both sharp corners (requires short lookahead) and straightaways (requires long lookahead) effectively. Without an adaptive lookahead based on curvature or speed, the robot oscillates on straights or cuts corners too aggressively.</li>
<li><strong>Unmodeled Dynamics &amp; Latency:</strong> Pure pursuit assumes instantaneous kinematic response. It fails to account for the Duckiebot’s system latency and tire slip at higher speeds. This sometimes results in a “reactive” driving style where the robot corrects errors only after they have accumulated, leading to jerky, oscillatory motion.</li>
</ul>
</section>
</section>
<section id="whats-next" class="level3">
<h3 class="anchored" data-anchor-id="whats-next">What’s next</h3>
<p>While our project successfully demonstrated lane-following in a closed loop environment, numerous opportunities exist to extend this foundation toward more robust and sophisticated autonomous navigation. We identified several directions for future development:</p>
<section id="improving-the-current-stack" class="level4">
<h4 class="anchored" data-anchor-id="improving-the-current-stack">Improving the current stack</h4>
<ul>
<li><p><strong>Robust Lane Boundaries Detection: </strong> We have seen that the current lane boundary detection is still not robust to outliers due to occlusion and lightning variation. Several strategies could be implemented to improve robustness. Temporal filtering could be leveraged to exploit the sequential nature of video suppress transient noise across consecutive frames. Region of interest masking could also be applied to constraint detection only around the region where lanes are expected to appear, which would reduce false positives coming from ceiling and irrelevant background elements. Most importantly, Bayesian filtering such as Kalman filters could be applied to maintain a probabilistic belief for the lane positions and orientation over time. This approach would enable the duckie to “remember” the lane boundaries during a brief occlusion.</p></li>
<li><p><strong>Smoother Trajectory Generation: </strong> The current RANSAC-based approach only minimize geometrical error and doesn’t account for jerky trajectories. Quadratic programming (QP) could be implemented to minimize for both the geometrical error and jerk behavior by defining constraints around velocity, acceleration and curvature limits.</p></li>
<li><p><strong>Improving Control Architecture: </strong> Pure pursuit works relatively well when we need to control around corner, but only takes into account heading error for more stable control. A naive improvement would be to include both PID and pure pursuit idea and include both cross-track error and heading error, something which Stanley control does quite well. Theoretically, Stanley control would be more stable at higher and lower speed because it would naturally transition between behaviors based on velocity: the heading term would dominate on higher speed and would gradually transition to CTE as it slows down.</p></li>
</ul>
</section>
<section id="going-further" class="level4">
<h4 class="anchored" data-anchor-id="going-further">Going Further</h4>
<ul>
<li><p><strong>Object Detection and Avoidance: </strong> Implementing pedestrian detection and integrating dynamic obstacle avoidance would be the first step toward context-aware navigation. Pedestrian detection could be solved using modern deep learning architecture such as YOLO or MobileNet while dynamic obstacle avoidance could be implemented using the Dynamic Window Approach (DWA). DWA samples commands and simulate their execution over a short horizon and selects the command which maximize progress toward the goal point while keeping the trajectory collision-free.</p></li>
<li><p><strong>Intersection Navigation: </strong> The second step towards context-aware navigation is to make the duckiebot drive around maps with intersections and introduces new challenges: stop line detection and turn signal interpretation. Successful behavior planning requires multi-stage hierarchical maneuver planning in order to plan what the duckie needs to do next: stop at the line, wait for traffic to clear, turn right, change lane, …</p></li>
<li><p><strong>Multi-Agent Coordination: </strong> The last step towards context-aware navigation is to add coordination inside the system, that is to make the duckiebot drive around other vehicles. Coordination requires a communication architecture for specific situations, mainly around intersection and traffic light. Simple heuristics around common driving courtesy (no hard breaks, FIFO at 4 points intersection, …) could first be implemented and then decentralized coordination second.</p></li>
</ul>


<!-- -->

</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Lane Following using Pure Pursuit Control"</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> </span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: "Emulie Chhor"</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation: "Université de Montréal"</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: "Kumaraditya Gupta"</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliation: "Université de Montréal"</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> today</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> "This project replaces the standard Duckietown lane following stack with a system that generates a local centerline trajectory. By tracking this path with a Pure Pursuit controller, the duckiebot achieves smoother navigation through curves and better resilience to noisy sensor data compared to previous PID-based approach."</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>{{&lt; include ./include/_introduction.qmd &gt;}}</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="fu">## Trajectory Generation</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>{{&lt; include ./include/_trajectory_generation.qmd &gt;}}</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pure Pursuit Control</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>{{&lt; include ./include/_pure_pursuit.qmd &gt;}}</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="fu">## Results</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>{{&lt; include ./include/_results.qmd &gt;}}</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a><span class="fu">## Testing</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>{{&lt; include ./include/_testing.qmd &gt;}}</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>{{&lt; include ./include/_conclusion.qmd &gt;}}</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>