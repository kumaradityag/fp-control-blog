This project successfully implemented a modular lane-following pipeline for the Duckiebot, moving away from the state estimation approach in favor of explicit trajectory generation and geometric path tracking. By leveraging robust polynomial fitting on ground-projected lane segments, we created a system capable of generating a centerline trajectory and following it using pure pursuit control.

Our experiments demonstrated that a pure pursuit controller, allows for continuous driving in both simulation and physical Duckietowns. While the transition from simulation to hardware introduced challenges regarding sensor noise and latency, the system proved that looking ahead at a generated path yields intuitive driving behavior. Our implementation also offers a flexible foundation for implementing more advanced planners and dynamic controllers in the future and general experimentation.

### Limitations

Although our pipeline performed well in simulation and achieved successful loops in real-world tests, the gap between simulation and reality exposed some weaknesses in both our trajectory generation and control algorithms.

#### Trajectory Generation Limitations

* **Single-Boundary Dependency:** Currently, the system fits a curve to either the white *or* the yellow lane markings, but does not fuse both simultaneously. This view of the road geometry creates instability: if the chosen boundary becomes sparse (but still above a given threshold) or occluded, the fit degrades immediately, even if the other boundary is clearly visible. A robust system could fit both boundaries jointly to maximize data utilization.
* **Model Constraints (The "S-Curve" Problem):** We model the lane as a quadratic polynomial. While robust for simple turns, a parabola cannot model inflection points (S-curves). If the vision horizon extends through a left-then-right turn, the quadratic fit will average the two curves into a straight line, causing the robot to drive off-road. Testing with a cubic polynomial in these situations might prove useful.

#### Pure Pursuit Limitations

Despite its computational efficiency, the pure pursuit controller exhibited some flaws when deployed on physical hardware:

* **Static Lookahead Sensitivity:** The controller is rigid; a fixed lookahead distance cannot handle both sharp corners (requires short lookahead) and straightaways (requires long lookahead) effectively. Without an adaptive lookahead based on curvature or speed, the robot oscillates on straights or cuts corners too aggressively.
* **Unmodeled Dynamics & Latency:** Pure pursuit assumes instantaneous kinematic response. It fails to account for the Duckiebot's system latency and tire slip at higher speeds. This sometimes results in a "reactive" driving style where the robot corrects errors only after they have accumulated, leading to jerky, oscillatory motion.

### What's next

While our project successfully demonstrated lane-following in a closed loop environment, numerous opportunities exist to extend this foundation toward more robust and sophisticated autonomous navigation. We identified several directions for future development:

#### Improving the current stack

* **Robust Lane Boundaries Detection: **
We have seen that the current lane boundary detection is still not robust to outliers due to occlusion and lightning variation. Several strategies could be implemented to improve robustness. Temporal filtering could be leveraged to exploit the sequential nature of video suppress transient noise across consecutive frames. Region of interest masking could also be applied to constraint detection only around the region where lanes are expected to appear, which would reduce false positives coming from ceiling and irrelevant background elements. Most importantly, Bayesian filtering such as Kalman filters could be applied to maintain a probabilistic belief for the lane positions and orientation over time. This approach would enable the duckie to “remember” the lane boundaries during a brief occlusion. 

* **Smoother Trajectory Generation: **
The current RANSAC-based approach only minimize geometrical error and doesn’t account for jerky trajectories. Quadratic programming (QP) could be implemented to minimize for both the geometrical error and jerk behavior by defining constraints around velocity, acceleration and curvature limits.

* **Improving Control Architecture: **
Pure pursuit works relatively well when we need to control around corner, but only takes into account heading error for more stable control. A naive improvement would be to include both PID and pure pursuit idea and include both cross-track error and heading error, something which Stanley control does quite well. Theoretically, Stanley control would be more stable at higher and lower speed because it would naturally transition between behaviors based on velocity: the heading term would dominate on higher speed and would gradually transition to CTE as it slows down.

#### Going Further

* **Object Detection and Avoidance: **
Implementing pedestrian detection and integrating dynamic obstacle avoidance would be the first step toward context-aware navigation. Pedestrian detection could be solved using modern deep learning architecture such as YOLO or MobileNet while dynamic obstacle avoidance could be implemented using the Dynamic Window Approach (DWA). DWA samples commands and simulate their execution over a short horizon and selects the command which maximize progress toward the goal point while keeping the trajectory collision-free.

* **Intersection Navigation: **
The second step towards context-aware navigation is to make the duckiebot drive around maps with intersections and introduces new challenges: stop line detection and turn signal interpretation. Successful behavior planning requires multi-stage hierarchical maneuver planning in order to plan what the duckie needs to do next: stop at the line, wait for traffic to clear, turn right, change lane, ...

* **Multi-Agent Coordination: **
The last step towards context-aware navigation is to add coordination inside
the system, that is to make the duckiebot drive around other vehicles. Coordination 
requires a communication architecture for specific situations, mainly around 
intersection and traffic light. Simple heuristics around common driving courtesy 
(no hard breaks, FIFO at 4 points intersection, ...) could first be implemented 
and then decentralized coordination second.

